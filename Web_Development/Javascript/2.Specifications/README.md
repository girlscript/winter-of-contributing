# The History of JavaScript

JavaScript is one of the most in-demand language, and for the seventh year in a row, it has been ranked the most commonly used programming language, with 67.8% of developers employing it in 2019. Its ascent to the world’s most popular programming language is synonymous with the rise of the internet itself.

Created out of necessity, it is used to build 95.2% (1.52 billion) of websites today, including some of the world’s largest, like Facebook and YouTube. Without it, we would not have popular and useful web apps such as Google Maps and eBay. 



# Javascript Specification (ECMA-262)

In 1997, due to JavaScript’s rapid growth, it became clear that the language would need to be properly maintained and managed. Therefore, Netscape handed the job of creating a language specification to the European Computer Manufacturers Association (ECMA), a body founded with the goal of standardizing computing. The ECMA specifications were labeled ECMA-262 and ECMAScript languages included JavaScript, JScript, and ActionScript.

Between 1997 and 1999, ECMA-262 had three revisions, but nearly 10 years later, version 4 was abandoned due to differing opinions on the direction of the language and its proposed features. Interestingly, many of these controversial features, such as generators, iterators, and destructuring assignments, have been included in more recent ECMAScript specifications.



# ECMAScript Specification

ECMAScript is the scripting language that forms the basis of JavaScript. ECMAScript standardized by the ECMA International standards organization in the ECMA-262 and ECMA-402 specifications. JavaScript was first known as LiveScript, but Netscape changed its name to JavaScript, possibly because of the excitement being generated by Java.

ECMA-262 is a standard published by Ecma International. It specifies a general-purpose scripting language. The language is called ECMAScript. The ECMAScript standard defines the rules, details, and guidelines that the scripting language must observe to be considered ECMAScript compliant.




# Versions of ECMAScript:

-**1st Edition**
    Launched in June 1997.

-**2nd Edition**
    Launched exactly after 1 year complition of 1st Edition launch, in June 1998.

-**3rd Edition**
    Launched in December 1999. Added some new features. Regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output, and other enhancements.

-**4th Edition**
    Fourth Edition was abandoned, due to political differences concerning language complexity. Many features proposed for the Fourth Edition have been completely dropped; some were incorporated into the sixth edition.

    By August 2008, the ECMAScript 4th edition proposal had been scaled back into a project code named ECMAScript Harmony. Features under discussion for Harmony at the time included:

1: Class:
        In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods). The name for the default constructor of the class (a subroutine that creates objects), and as the type of objects generated by instantiating the class, these distinct concepts are easily conflated.

        Structure of class:
        A class contains data field descriptions (or properties, fields, data members, or attributes). These are usually field types and names that will be associated with state variables at program run time; these state variables either belong to the class or specific instances of the class.

        Inter-class Relationships:
        In addition to the design of standalone classes, programming languages may support more advanced class design based upon relationships between classes. The inter-class relationship design capabilities commonly provided are compositional and hierarchical.

            Compositional:
            Classes can be composed of other classes, thereby establishing a compositional relationship between the enclosing class and its embedded classes. Compositional relationship between classes is also commonly known as a has-a relationship.
            For example, a class "Car" could be composed of and contain a class "Engine". Therefore, a Car has an Engine. One aspect of composition is containment, which is the enclosure of component instances by the instance that has them.
            If an enclosing object contains component instances by value, the components and their enclosing object have a similar lifetime. If the components are contained by reference, they may not have a similar lifetime. 
            For example, in Objective-C 2.0:

            @interface Car : NSObject

            @property NSString *name;
            @property Engine *engine
            @property NSArray *tires;

            @end
            This Car class has an instance of NSString (a string object), Engine, and NSArray (an array object).

            Hierarchical:
            Classes can be derived from one or more existing classes, thereby establishing a hierarchical relationship between the derived-from classes. Derived classes can define additional structural members (data fields) and behavioral members (methods) in addition to those that they inherit and are therefore specializations of their superclasses. Also, derived classes can override inherited methods if the language allows. Not all languages support multiple inheritance. For example, Java allows a class to implement multiple interfaces, but only inherit from one class.[20] If multiple inheritance is allowed, the hierarchy is a directed acyclic graph (or DAG for short), otherwise it is a tree. The hierarchy has classes as nodes and inheritance relationships as links. Classes in the same level are more likely to be associated than classes in different levels. The levels of this hierarchy are called layers or levels of abstraction.

            Example (Simplified Objective-C 2.0 code, from iPhone SDK):

            @interface UIResponder : NSObject //...
            @interface UIView : UIResponder //...
            @interface UIScrollView : UIView //...
            @interface UITableView : UIScrollView //...
            In this example, a UITableView is a UIScrollView is a UIView is a UIResponder is an NSObject.
    

2: Module:
        Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.


-Optional type annotations and static typing, probably using a structural type system:
        Static type checking is the process of verifying the type safety of a program based on analysis of a program's text
        (source code). If a program passes a static type checker, then the program is guaranteed to satisfy some set of type 
        safety properties for all possible inputs.
        Static type checking for Turing-complete languages is inherently conservative. That is, if a type system is both sound (meaning that it rejects all incorrect programs) and decidable (meaning that it is possible to write an algorithm that determines whether a program is well-typed), then it must be incomplete (meaning there are correct programs, which are also rejected, even though they do not encounter runtime errors).
        For example, consider a program containing the code:

if <complex test> then <do something> else <signal that there is a type error>

        Even if the expression <complex test> always evaluates to true at run-time, most type checkers will reject the program as ill-typed, because it is difficult (if not impossible) for a static analyzer to determine that the else branch will not be taken.

3: Generators and Iterators:
        A generator is a routine that can be used to control the iteration behaviour of a loop. All generators are also iterators.[1] A generator is very similar to a function that returns an array, in that a generator has parameters, can be called, and generates a sequence of values. Generators first appeared in CLU (1975), were a prominent feature in the string manipulation language Icon (1977) and are now available in Python (2001), C#, Ruby, the later versions of ECMAScript (as of ES6/ES2015) and other languages.

        Lisp
        The final Common Lisp standard does not natively provide generators, yet various library implementations exist, such as SERIES documented in CLtL2 or pygen.


        CLU
        A yield statement is used to implement iterators over user-defined data abstractions.

        string_chars = iter (s: string) yields (char);
        index: int := 1;
        limit: int := string$size (s);
        while index <= limit do
        yield (string$fetch(s, index));
        index := index + 1;
        end;
        end string_chars;

        for c: char in string_chars(s) do
           ...
        end;


        Icon
        Every expression (including loops) is a generator. The language has many generators built-in and even implements some of the logic      semantics using the generator mechanism (logical disjunction or "OR" is done this way).

        Printing squares from 0 to 20 can be achieved using a co-routine by writing:

           local squares, j
           squares := create (seq(0) ^ 2)
           every j := |@squares do
           if j <= 20 then
               write(j)
           else
               break

        C++
        It is possible to introduce generators into C++ using pre-processor macros. The set of pre-processor macros defined in this source allow generators defined with the syntax as in the following example:

        $generator(descent)
        {
           int i;

           // place the constructor of our generator, e.g. 
           // descent(int minv, int maxv) {...}

           // from $emit to $stop is a body of our generator:

           $emit(int) // will emit int values. Start of body of the generator.
              for (i = 10; i > 0; --i)
                 $yield(i); // similar to yield in Python,
                            // returns next number in [1..10], reversed.
           $stop; // stop, end of sequence. End of body of the generator.
        };
        This can then be iterated using:

        int main(int argc, char* argv[])
        {
          descent gen;
          for(int n; gen(n);) // "get next" generator invocation
            printf("next number is %d\n", n);
          return 0;
        }

        Moreover, C++11 allows foreach loops to be applied to any class that provides the begin and end functions. It's then possible to write generator-like classes by defining both the iterable methods (begin and end) and the iterator methods (operator!=, operator++ and operator*) in the same class. For example, it is possible to write the following program:

        #include <iostream>
        int main()
        {
            for (int i: range(10))
            {
                std::cout << i << std::endl;
            }
            return 0;
        }

        A basic range implementation would look like that:

        class range
        {
        private:
            int last;
            int iter;

        public:
            range(int end):
                last(end),
                iter(0)
            {}

            // Iterable functions
            const range& begin() const { return *this; }
            const range& end() const { return *this; }

            // Iterator functions
            bool operator!=(const range&) const { return iter < last; }
            void operator++() { ++iter; }
            int operator*() const { return iter; }
        };

4: Destructuring Assignments:
        In Mozilla's JavaScript, since version 1.7, destructuring assignment allows the assignment of parts of data structures to several variables at once. The left hand side of an assignment is a pattern that resembles an arbitrarily nested object/array literal containing l-lvalues at its leaves that are to receive the substructures of the assigned value.
        var a, b, c, d, e;
        [a, b, c] = [3, 4, 5];
        console.log(a + ',' + b + ',' + c); // displays: 3,4,5
        e = {foo: 5, bar: 6, baz: ['Baz', 'Content']};
        var arr = [];
        ({baz: [arr[0], arr[3]], foo: a, bar: b}) = e;
        console.log(a + ',' + b + ',' + arr);	// displays: 5,6,Baz,,,Content
        [a, b] = [b, a];		// swap contents of a and b
        console.log(a + ',' + b);		// displays: 6,5

        [a, b, c] = [3, 4, 5]; // permutations
        [a, b, c] = [b, c, a];
        console.log(a + ',' + b + ',' + c); // displays: 4,5,3

5: Algebraic Datatypes:
        In computer programming, especially functional programming and type theory, an algebraic data type is a kind of composite type, i.e., a type formed by combining other types.

        Two common classes of algebraic types are product types (i.e., tuples and records) and sum types (i.e., tagged or disjoint unions, coproduct types or variant types).



-**5th Edition**
    Launched in December 2009. Adds "strict mode," a subset intended to provide more thorough error checking and avoid error-prone constructs. Clarifies many ambiguities in the 3rd edition specification, and accommodates behaviour of real-world implementations that differed consistently from that specification. Adds some new features, such as getters and setters, library support for JSON, and more complete reflection on object properties.

-**5.1 Edition**
    Launched in June 2011, this edition 5.1 of the ECMAScript standard is fully aligned with the third edition of the international standard ISO/IEC 16262:2011.

-**6th Edition**
    The 6th edition, ECMAScript 6 (ES6) and later renamed to ECMAScript 2015, was finalised in June 2015.This update adds significant new syntax for writing complex applications, including class declarations (class Foo { ... }), ES6 modules like import * as moduleName from "..."; export const Foo, but defines them semantically in the same terms as ECMAScript 5 strict mode. As the first "ECMAScript Harmony" specification, it is also known as "ES6 Harmony." Other new features include iterators and for...of loops, Python-style generators, arrow function expression (() => {...}), let keyword for local declarations, const keyword for constant local declarations, binary data, typed arrays, new collections (maps, sets and WeakMap), promises, number and math enhancements, reflection, proxies etc.

1: Promise & Future:
        In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program execution in some concurrent programming languages. The term promise was proposed in 1976 by Daniel P. Friedman and David Wise, and Peter Hibbard called it eventual. A somewhat similar concept future was introduced in 1977 in a paper by Henry Baker and Carl Hewitt.

        Promise pipelining:
            The use of futures can dramatically reduce latency in distributed systems. For instance, futures enable promise pipelining, as implemented in the languages E and Joule, which was also called call-stream in the language Argus.

            Consider an expression involving conventional remote procedure calls, such as:

             t3 := ( x.a() ).c( y.b() )
            which could be expanded to

             t1 := x.a();
             t2 := y.b();
             t3 := t1.c(t2);

            Each statement needs a message to be sent and a reply received before the next statement can proceed. 
            Using futures, the above expression could be written

            t3 := (x <- a()) <- c(y <- b())
            which could be expanded to

             t1 := x <- a();
             t2 := y <- b();
             t3 := t1 <- c(t2);

-**7th Edition**
    The 7th edition, or ECMAScript 2016, was finalised in June 2016. Its features include block-scoping of variables and functions, destructuring patterns (of variables), proper tail calls, exponentiation operator ** for numbers, await, async keywords for asynchronous programming (as a preparation for ES2017), and the Array.prototype.includes function.

-**8th Edition**
    The 8th edition, or ECMAScript 2017, was finalised in June 2017. Its features include the Object.values, Object.entries and Object.getOwnPropertyDescriptors functions for easy manipulation of Objects, async/await constructions which use generators and promises, and additional features for concurrency and atomics.

-**9th Edition**
    The 9th edition, or ECMAScript 2018, was finalised in June 2018.[14] New features include the spread operator, rest parameters, asynchronous iteration, Promise.prototype.finally and additions to RegExp.[14]

    The spread operator allows for the easy copying of object properties, as shown below.

    let object = {a: 1, b: 2}
    
    let objectClone = Object.assign({}, object) // before ES9
    let objectClone = {...object} // ES9 syntax
    
    let otherObject = {c: 3, ...object}
    console.log(otherObject) // -> {c: 3, a: 1, b: 2}

-**10th Edition**
    The 10th edition, or ECMAScript 2019, was published in June 2019. Added features include, but are not limited to, Array.prototype.flat, Array.prototype.flatMap, changes to Array.sort and Object.fromEntries.

-**11th Edition**
    The 11th edition, or ECMAScript 2020, was published in June 2020. In addition to new functions, this version introduces a BigInt primitive type for arbitrary-sized integers, the nullish coalescing operator, and the globalThis object.
    The nullish coalescing operator, ??, returns its right-hand side operand when its left-hand side is null or undefined. This contrasts with the || operator, which would return "string" for all "falsy" values, such as the ones below.

    undefined ?? "string" // -> "string"
    null ?? "string" // -> "string"
    false ?? "string" // -> false
    NaN ?? "string" // -> NaN
    Optional chaining makes it possible to access the nested properties of an object without having an AND check at each level.
    
    An example is const zipcode = person?.address?.zipcode. If any of the properties are not present, zipcode will be undefined.

-**12th Edition**
    The 12th edition, or ECMAScript 2021, was published in June 2021. This version introduces the replaceAll method for strings, a promise combinator that short-circuits when an input value is fulfilled, AggregateError, a new error type to represent multiple errors at once, logical assignment operators (??=, &&=, ||=), WeakRef, for referring to a target object without preserving it from garbage collection, and FinalizationRegistry, to manage registration and unregistration of cleanup operations performed when target objects are garbage collected, separators for numeric literals (1_000) and Array.prototype.sort was made more precise, reducing the amount of cases that result in an implementation-defined sort order.

-**ES.Next**
    ES.Next is a dynamic name that refers to whatever the next version is at the time of writing. ES.Next features include finished proposals (aka "stage 4 proposals") as listed at finished proposals that are not part of a ratified specification. The language committee follows a "living spec" model, so these changes are part of the standard, and ratification is a formality.




# Advantages:

- **Speed**: Client-side JavaScript is very fast because it can be run immediately within the client-side browser. Unless outside resources are required, JavaScript is unhindered by network calls to a backend server.

- **Simplicity**: JavaScript is relatively simple to learn and implement.

- **Popularity**: JavaScript is used everywhere on the web.

- **Interoperability**: JavaScript plays nicely with other languages and can be used in a huge variety of applications.

- **Server Load**: Being client-side reduces the demand on the website server.

- **Interface**: Gives the ability to create rich interfaces.

