# HELM

![image](https://user-images.githubusercontent.com/71754779/133918317-e7de9a05-61fe-4946-9d7c-3d15b76e7897.png)

# What is Helm

Helm is a tool for managing Charts. Charts are packages of pre-configured Kubernetes resources. Helm is a package manager for Kubernetes. Helm is the K8s equivalent of yum or apt. Helm deploys charts, which you can think of as a packaged application. It is a collection of all your versioned, pre-configured application resources which can be deployed as one unit. You can then deploy another version of the chart with a different set of configuration.

# How does Helm help us

Helm help us in three ways:

* Improves productivity
* Reduces the complexity of deployments of microservices
* Enables the adaptation of cloud native applications

# What are the uses of Helm?

Helm is a client/server application and, until recently, has relied on Tiller(the helm server) to be deployed in your cluster. This gets installed when installing helm on your client machine.Tiller simply receives requests from the client and installs the package into your cluster. Helm can be easily compared to RPM of DEB packages in Linux, providing a convenient way for developers to package and ship an application to their end users to install.Writing and maintaining Kubernetes YAML manifests for all the required Kubernetes objects can be a time consuming and tedious task. For the simplest of deployments, you would need at least 3 YAML manifests with duplicated and hardcoded values. Helm simplifies this process and creates a single package that can be advertised to your cluster.

# What are Helm charts?

Helm Charts are simply Kubernetes YAML manifests combined into a single package that can be advertised to your Kubernetes clusters. Once packaged, installing a Helm Chart into your cluster is as easy as running a single helm install, which really simplifies the deployment of containerized applications.

![image](https://user-images.githubusercontent.com/71754779/133918738-500fbc0c-e8cb-4ab4-8293-67f04d964ab3.png)

# Describing Helm

***Helm has two parts to it:***

* The client (CLI), which lives on your local workstation.
* The server (Tiller), which lives on the Kubernetes cluster to execute what’s needed.

The idea is that you use the CLI to push the resources you need and tiller will make sure that state is in fact the case by creating/updating/deleting resources from the chart. To fully grasp helm, there are 3 concepts we need to get familiar with:

* **Chart**: A package of pre-configured Kubernetes resources.
* **Release**: A specific instance of a chart which has been deployed to the cluster using Helm.
* **Repository**: A group of published charts which can be made available to others.

# Benefits of Helm

***Developers like Helm charts for many reasons:***

* Boosts Productivity
* Reduces duplication and complexity
* Smooths the K8S learning curve
* Simplifies deployments

# Describing a Helm Chart

Helm has a certain structure when you create a new chart. To create, run *“helm create* ***YOUR-CHART-NAME”***. Once this is created, the directory structure should look like:

```
YOUR-CHART-NAME/
 |
 |- .helmignore 
 | 
 |- Chart.yaml 
 | 
 |- values.yaml 
 | 
 |- charts/ 
 |
 |- templates/
```

* **.helmignore**: This holds all the files to ignore when packaging the chart. Similar to .gitignore, if you are familiar with git.
* **Chart.yaml**: This is where you put all the information about the chart you are packaging. So, for example, your version number, etc. This is where you will put all those details.
* **Values.yaml**: This is where you define all the values you want to inject into your templates. If you are familiar with terraform, think of this as helms variable.tf file.
* **Charts**: This is where you store other charts that your chart depends on. You might be calling another chart that your chart need to function properly.
* **Templates**: This folder is where you put the actual manifest you are deploying with the chart. For example you might be deploying an nginx deployment that needs a service, configmap and secrets. You will have your deployment.yaml, service.yaml, config.yaml and secrets.yaml all in the template dir. They will all get their values from values.yaml from above.

# Helm simplifies software deployment

In summary, Helm takes a lot of the complexity out of deploying software and your own applications to Kubernetes. It can be installed in a matter of minutes and you can be deploying charts from the stable repository in no time. Writing your own charts is also a straightforward process, though does require understanding of Kubernetes objects. Helm can empower your developers to work more efficiently giving them the tools they need to test their code locally.

***References***

* BMC Blog :- https://www.bmc.com/blogs/kubernetes-helm-charts/
