# Array Rearrangement 

## Problem Statement :- Minimum swaps required to bring elements less than equal to k together, STL implementations of rearrangement(sort comparator etc).

### Example
```
Input:- arr[] = {2, 5, 7, 11, 6}, k=6
Output:- 1
Explanation:- We will only need to swap '6' with '7' to bring '2', '5', '6' together. Thus the output is 1. Final array will be- {2, 5, 6, 11, 7}


Input:- arr[] ={2, 5, 6, 13, 46, 7, 9}, k=9
Output:- 5
```


## Approach
> A simple approach will be to count all the numbers smaller equal to k. Now traverse again in the array to swap all the elements greater than k. This approach is based on *Two Pointer Technique* and *Sliding Window*.

## Algorithm
1. Count all the elements which are smaller or equal to 'k' and store them in a variable count.
2. Using two pointer technique for window of length ‘cnt’, each time keep track of how many elements in this range are greater than ‘k’. Let’s say the total count is ‘bad’.
3. Repeat step 2, for every window of length ‘cnt’ and take minimum of count ‘bad’ among them. This will be the final answer.

## Implementation

### C++ implementation

```

#include <iostream>
using namespace std;

int minSwap(int *arr, int n, int k) {
	
	// Count of elements which are <= k
	int count = 0;
	for (int i = 0; i < n; ++i)
		if (arr[i] <= k)
			++count;
	
	// count the extra elements i.e., element>k
	int bad = 0;
	for (int i = 0; i < count; ++i)
		if (arr[i] > k)
			++bad;
	
	// Initialize answer with 'bad' value
	int ans = bad;
	for (int i = 0, j = count; j < n; ++i, ++j) {
		
		if (arr[i] > k)
			--bad;
		
		if (arr[j] > k)
			++bad;
		
		// Update ans if count of 'bad' is less in current window
		ans = min(ans, bad);
	}
	return ans;
}


int main() {
	
    int size;
    cin>>size;
    int arr[size];
    for(int i=0; i<size; i++)
        cin>>arr[i];
	int k;
    cin>>k;
	cout << minSwap(arr, size, k);
	return 0;
}

```


### Java implementation
```

import java.lang.*;
import java.util.*;
class GFG {
	
static int minSwap(int arr[], int n, int k) {

	// Count of elements which are <= k
	int count = 0;
	for (int i = 0; i < n; ++i)
	if (arr[i] <= k)
		++count;

	// count the extra elements i.e., element>k
	int bad = 0;
	for (int i = 0; i < count; ++i)
	if (arr[i] > k)
		++bad;

	// Initialize answer with 'bad' value 
	int ans = bad;
	for (int i = 0, j = count; j < n; ++i, ++j) {

	if (arr[i] > k)
		--bad;

	if (arr[j] > k)
		++bad;

	// Update ans if count of 'bad'
	// is less in current window
	ans = Math.min(ans, bad);
	}
	return ans;
}


public static void main(String[] args)
{
    Scanner sc= new Scanner(System.in);
        int n = sc.nextInt();
		int [] arr = new int[n];
	    for(int i=0; i<n; i++){
	        arr[i]= sc.nextInt();
	    }
	    int k= sc.nextInt();
	System.out.println(minSwap(arr, n, k));

	
}
}

```


### C implementation
```

#include <stdio.h>

int minSwap(int arr[], int n, int k) {
	
    // Count of elements which are <= k
	int count = 0;
	for (int i = 0; i < n; ++i)
		if (arr[i] <= k)
			++count;
	
	// count the extra elements i.e., element>k
	int bad = 0;
	for (int i = 0; i < count; ++i)
		if (arr[i] > k)
			++bad;
	
	// Initialize answer with 'bad' value
	int ans = bad;
	for (int i = 0, j = count; j < n; ++i, ++j) {
		
		if (arr[i] > k)
			--bad;
		
		if (arr[j] > k)
			++bad;
		
		// Update ans if count of 'bad' is less in current window
		if(ans>bad)
		ans = bad;
	}
	return ans;
}


int main(void) {
	
    int size;
    scanf("%d",&size);
    int arr[size];
    for(int i=0; i<size; i++)
        scanf("%d",&arr[i]);
	int k;
    scanf("%d",&k);
	printf("%d",minSwap(arr, size, k));
	return 0;
}

```