## Problem Statement
Given an array of N integers arr[] where each element represents the max number of steps that can be made forward from that element. Find the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then you cannot move through that element.
Note: Return -1 if you can't reach the end of the array.
<hr>

## Example
```
Input: arr[] = [2, 3, 2, 4, 4] 
Output: 2 (2 -> 3 -> 4)
Explanation: Jump from index 0 to 1 ,then 3 steps to the last index.
```
<hr>

## Method 1 : Naive Approach 
Start from the first element and recursively call for all the elements reachable from first element. The minimum number of jumps to reach end from first can be calculated using minimum number of jumps needed to reach end from the elements reachable from first. 
```
minJumps(start, end) = Min ( minJumps(k, end) ) for all k reachable from start 
```

### Code 
``` C++
#include <bits/stdc++.h>
using namespace std;
int minJumps(int arr[], int n) //function to return min jumps
{
 
    if (n == 1) //base case 
        return 0;

    int ans = INT_MAX;
    for (int i = n - 2; i >= 0; i--) { //traverse arr 
        if (i + arr[i] >= n - 1) {
            int smallAns = minJumps(arr, i + 1);
            if (smallAns != INT_MAX)
                ans = min(ans, smallAns + 1);
        }
    }
 
    return ans;
}
int main()
{
    int arr[1000],n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    cout << "Minimum number of jumps needed to reach end is " << minJumps(arr, n);
    return 0;
}
```

### Input
```
3
1 2 1
```

### Ouput
```
Minimum number of jumps needed to reach end is 2
```

### Complexity
**Time complexity: `O(n^n)`** 

<hr>


## Method 2 : Dynamic Programming. 
1. Declare a jmp[] array from left to right such that jmp[i] indicate the minimum number of jumps needed to reach arr[i] from arr[0].
2. Fill the jmp[] using loop.Outer loop from 1 to n-1 and inner loop from 0 to i.
3. if i is less than j + arr[j] then set jmp[i] to minimum of jmp[i] and jmp[j] + 1. 
4. Return jmp[n-1].

### Code
```C++
#include <bits/stdc++.h>
using namespace std;
// Returns minimum number of jumps
int minJumps(int arr[], int n)
{
    // jumps[n-1] will hold the result
    int  *jmp = new int[n];
    int i, j;
 
    if (n == 0 || arr[0] == 0)
        return INT_MAX;
 
    jmp[0] = 0;
    for (i = 1; i < n; i++) {
        jmp[i] = INT_MAX;
        for (j = 0; j < i; j++) {
            if (i <= j + arr[j] && jmp[j] != INT_MAX) {
                jmp[i] = min(jmp[i], jmp[j] + 1);
                break;
            }
        }
    }
    return jmp[n - 1];
}
 

int main()
{
    int arr[1000],n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    cout << "Minimum number of jumps needed to reach end is " << minJumps(arr, n);
    return 0;
}
```
### Input
```
4
1 1 1 1
```
### Output 
```
Minimum number of jumps needed to reach end is 3
```

### Complexity 
**Time Complexity: `O(n^2)`**



