## How to crack Technical Interviews

These are some most important points that you should keep in mind while preparing for interviews other than **Problem Solving Skills**.

- Communication is the key
- Clarifying Questions and Dry run
- Brute Force
- Taking help from the interviewer
- Clean Code
- Test
- Time Complexity and Space Complexity

## 1. Communication is the key:

Practice talking to yourself while coding so you can maintain your speed during the interview as well because Interviews are meant to test your communication skills more than anything else. Your interviewer already knows how to solve the question that’s been given, but they need to see if you can explain it to them while coding. Your main priority is to prove the interviewer that you know what you’re doing.

Talk aloud while coding. Explain what algorithm you’re using and why, what data structure you’ve chosen and why, what variables you’ve defined and why, every aspect of control flow in your code.

## 2. Clarifying Questions and Dry run:

Your interviewer is most likely to give you an ambiguous question - you are expected to ask clarifying questions. You will rarely get constraints or specifics about the question like you are used to seeing in CP. They want to test if you ask the right questions when given only partial information. The worst thing you can do here is make assumptions. In case your assumption is wrong, you will have wasted your time coding a solution to the wrong question. Your interviewer will not stop you if you’ve gone down the wrong path until you ask them - it is your own responsibility to make sure you have understood the question properly.

In case you have not been able to ask good clarifying questions, this step acts as an additional safety net. Come up with an example test case by yourself for the problem and ask if the output is aligned with the interviewer’s expectations. Use this opportunity to ask about corner cases too. In case you’ve misunderstood the question, you allow the interviewer to correct you at this point before you start coding.

## 3. Brute Force:

Your primary objective must be to solve the problem. If you cannot come up with the best solution straightaway, that is alright. You will be given the chance to optimize it later on. 

Don’t fixate on the time complexity if you cannot think of one and get stuck. Don’t stay silent if you can only think of the brute force approach. Often, your interviewer will help you if you tell them what approach you’re thinking of. If you’re silent, it may be assumed that you haven’t even been able to think of a brute force approach, and that is a discredit to you.

## 4. Taking help from the interviewer:

I have just previously mentioned that your interviewer is also available to help you out if you’re stuck. Think of it like using up hints in a game show. The help is valuable, but costly, because your interviewer will keep track of the number of hints you’ve taken, and the less help you’ve required, the better - so try to do it on your own and avoid taking hints from the interviewer.

However, taking help is much better than staying blank. Asking for help when you are stuck is a good trait. So depending on your situation, decide if you need to ask for hints or not.

One very important point about hints is - if you’ve received a hint from your interviewer, you must take it. Do not ignore what they’re saying (they will never directly say things, it would be mostly in the form of a question or suggestion). Everything they say during the interview is to guide you in the right direction, so if they’re giving you a hint, actually think about it. If your interviewer gives you a hint but you do not take it, it will be assumed that you are unable to recognize help even when you need it - and this does not look good.

## 5. Clean Code:

Code in major companies is read much more than they’re written. Your code needs to be clean enough to allow anyone to read and understand easily. Look up topics on code readability. Employ tactics such as functional decomposition, refactored code, good naming practices, code reusability.

Stick to the prescribed style guidelines for your language. If you’re coding in Python, use the PEP-8 style guidelines and make your code as pythonic as possible. Code conventions are very strict in companies and they prefer candidates who are already a good fit for contributing to the code base. There are some differences in convention depending on the companies, but these differences are minor enough to be ignored for now.

## 6. Test:

Once you’ve written your code, test it vigorously. When you’re coding in an interview, you will be coding on Docs, or some kind of text editor. There will be no provision for you to compile or run your code. We often rely on editors to highlight our syntax errors, or run test cases to realise if our solution is correct. You will not get this opportunity in an interview so you will have to catch your own bugs. Your code would be considered perfect if it’s clean, gives the correct solution and can be copy-pasted into an editor and run without any issues.

To get used to coding on docs without depending on editors or compilers, practice coding on text editors before the actual interview so that you’re comfortable enough during it.

This step also shows your interviewer that you know the importance of tests. In a company, you would be asked to write unit tests to accompany every new piece of code that’s been written, so testing is a very good habit.

## 7. Time Complexity and Space Complexity:

In a technical interview, you are expected to know your language inside out. It is very important that you are able to do the time complexity and space complexity analysis on the spot during the interview. In order to do this, you need to know the time complexities of all the operations you have used in your code.

Making a mistake in time complexity and space complexity is fatal, since time complexity analysis is considered to be a fundamental skill in computer science and any decent coder is expected to know their basics in computational theory well. Be well-versed with complexities and analysis before your interview and understand your data structures and algorithms properly.





